# 信号语义（Signal Semantics）

本文件专门说明项目中信号/槽（signals/slots）的语义与建议实践，包括：同步/异步触发语义、是否在锁内执行回调、回调的错误处理、优先级与执行顺序、以及对长时间运行回调的处理建议。

## 目标
- 明确信号的语义，避免用户误用导致竞态或死锁。
- 提供推荐的使用模式与范例代码，便于对接监控/追踪系统。

## 基本定义
- **同步触发（synchronous）**：发信号的线程在调用发射（emit）时，同步执行所有槽函数并在返回前完成。
- **异步触发（asynchronous）**：发信号的线程将回调入队或交给线程池执行，emit 返回并不等待回调完成。

> 在本库中：默认实现为 **同步触发并在最小锁作用域内执行可控回调**，但某些信号（例如长期 I/O 回调）建议使用异步 offload 模式（见下文）。

## 同步 vs 异步：何时使用
- 同步：用于轻量回调，需要保证顺序与即时性（例如状态标记、统计计数）。
- 异步：用于可能阻塞、耗时或进行 I/O 的回调（例如日志写入、发送网络请求、复杂分析）。

### 建议
- 在槽函数中避免执行长时间阻塞的操作；若必须，使用异步 offload（例如提交到 Executor / std::async / 自己的线程池）。
- 对于必须保证顺序通知的场景，使用同步触发并在外层控制并发。

## 回调执行时是否持有锁？
- 原则：**信号在触发时应尽量减少锁持有时长**。若必须在锁内触发（以保证顺序性），文档会明确指出并在 signal 名称或注释中标注“锁内触发”。
- 对使用者：不要在回调中假设库将在锁外执行，尽量避免在回调里再次访问需要获得相同库内部锁的数据结构，或使用 try_lock/延迟处理策略。

## 优先级与执行顺序
- 信号支持优先级注册：高优先级的槽会先被执行（同一优先级内按注册顺序执行）。
- 在同步模式下，优先级可用于实现层次化监听（例如先做校验再做副作用）。

## 异常与错误处理
- 槽函数抛出的异常应由信号发射方捕获并处理：建议将异常包装成 `TaskResult` 或 `Error` 并作为结果上报。
- 不建议让异常跨越信号边界未处理（这可能导致调用链不稳定）。

## 示例：安全地在回调中执行 I/O（异步 offload）
```cpp
// 在槽中立即提交到线程池以避免阻塞库线程
task->sig_completed().connect([tp](const std::shared_ptr<Task>& t, const TaskResult& r){
    auto task_copy = t; // 持有 shared_ptr 确保对象存活
    tp->submit([task_copy, r]{
        // 长时间 I/O 操作，例如写入外部系统
        log_to_remote(task_copy->id(), r.summary);
    });
});
```

## 追踪与监控建议
- 在信号发射处生成并传递 trace_id（若有 tracing 支持），便于跨线程/跨服务追踪。`TaskMeta`/`Task` 可携带 `trace_id` 字段。
- 推荐为重要信号（如 `sig_task_completed`）记录轻量指标（触发延迟、处理耗时、队列长度）。

## 兼容性与扩展
- 将来可支持配置化信号分发器（可注入的 Dispatcher/Executor），以适配高并发、限速或优先级处理策略（参见 `docs/maintenance/todo.md` 中的 Executor 设计讨论）。

---

## 参考
- `docs/maintenance/todo.md`（Async Executor 设计讨论）
- `docs/developer/DEVELOPER_GUIDE.md`（开发者指南）
- `docs/api/API.md`（信号 API 参考）
